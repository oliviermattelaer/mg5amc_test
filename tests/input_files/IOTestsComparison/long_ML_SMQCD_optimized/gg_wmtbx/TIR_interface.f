      SUBROUTINE ML5_0_TIRLOOP(I_SQSO,I_LOOPGROUP,I_LIB,NLOOPLINE,PL
     $ ,M2L,RANK,RES,STABLE)
C     
C     Generated by MadGraph5_aMC@NLO v. %(version)s, %(date)s
C     By the MadGraph5_aMC@NLO Development Team
C     Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
C     
C     Interface between MG5 and TIR.
C     
C     Process: g g > w- t b~ QED=1 QCD=2 [ virt = QCD ]
C     
C     
C     CONSTANTS 
C     
      INTEGER NLOOPGROUPS
      PARAMETER (NLOOPGROUPS=77)
C     These are constants related to the split orders
      INTEGER NSQUAREDSO
      PARAMETER (NSQUAREDSO=0)
      INTEGER LOOPMAXCOEFS
      PARAMETER (LOOPMAXCOEFS=70)
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      LOGICAL CHECKPCONSERVATION
      PARAMETER (CHECKPCONSERVATION=.TRUE.)
      REAL*8 NORMALIZATION
      PARAMETER (NORMALIZATION = 1.D0/(16.D0*3.14159265358979323846D0*
     $ *2))
C     
C     ARGUMENTS 
C     
      INTEGER I_SQSO,I_LOOPGROUP,I_LIB
      INTEGER NLOOPLINE, RANK
      REAL*8 PL(0:3,NLOOPLINE)
      REAL*8 PCT(0:3,0:NLOOPLINE-1)
      REAL*8 PDEN(0:3,NLOOPLINE-1)
      COMPLEX*16 M2L(NLOOPLINE)
      COMPLEX*16 M2LCT(0:NLOOPLINE-1)
      COMPLEX*16 RES(3)
      LOGICAL STABLE
C     
C     LOCAL VARIABLES 
C     
      INTEGER I, J, K
      INTEGER NLOOPCOEFS
      LOGICAL CTINIT, TIRINIT
      COMMON/REDUCTIONCODEINIT/CTINIT,TIRINIT

      COMPLEX*16 TIRCOEFS(0:LOOPMAXCOEFS-1,3)
      COMPLEX*16 PJCOEFS(0:LOOPMAXCOEFS-1,3)
C     
C     EXTERNAL FUNCTIONS
C     
C     
C     GLOBAL VARIABLES
C     
      INCLUDE 'MadLoopParams.inc'
      INCLUDE 'coupl.inc'
      INTEGER CTMODE
      REAL*8 LSCALE
      COMMON/ML5_0_CT/LSCALE,CTMODE


      COMPLEX*16 LOOPCOEFS(0:LOOPMAXCOEFS-1,NSQUAREDSO,NLOOPGROUPS)
      COMMON/ML5_0_LCOEFS/LOOPCOEFS

C     ----------
C     BEGIN CODE
C     ----------

C     INITIALIZE TIR IF NEEDED
      IF (TIRINIT) THEN
        TIRINIT=.FALSE.
        CALL ML5_0_INITTIR()
      ENDIF

C     CONVERT THE MASSES TO BE COMPLEX
      DO I=1,NLOOPLINE
        M2LCT(I-1)=M2L(I)
      ENDDO

C     CONVERT THE MOMENTA FLOWING IN THE LOOP LINES TO CT CONVENTIONS
      DO I=0,3
        DO J=0,(NLOOPLINE-1)
          PCT(I,J)=0.D0
        ENDDO
      ENDDO
      DO I=0,3
        DO J=1,NLOOPLINE
          PCT(I,0)=PCT(I,0)+PL(I,J)
        ENDDO
      ENDDO
      IF (CHECKPCONSERVATION) THEN
        IF (PCT(0,0).GT.1.D-6) THEN
          WRITE(*,*) 'energy is not conserved ',PCT(0,0)
          STOP 'energy is not conserved'
        ELSEIF (PCT(1,0).GT.1.D-6) THEN
          WRITE(*,*) 'px is not conserved ',PCT(1,0)
          STOP 'px is not conserved'
        ELSEIF (PCT(2,0).GT.1.D-6) THEN
          WRITE(*,*) 'py is not conserved ',PCT(2,0)
          STOP 'py is not conserved'
        ELSEIF (PCT(3,0).GT.1.D-6) THEN
          WRITE(*,*) 'pz is not conserved ',PCT(3,0)
          STOP 'pz is not conserved'
        ENDIF
      ENDIF
      DO I=0,3
        DO J=1,(NLOOPLINE-1)
          DO K=1,J
            PCT(I,J)=PCT(I,J)+PL(I,K)
          ENDDO
        ENDDO
      ENDDO

      DO I=0,3
        DO J=1,(NLOOPLINE-1)
          PDEN(I,J)=PCT(I,J)
        ENDDO
      ENDDO
C     NUMBER OF INDEPEDENT LOOPCOEFS FOR RANK=RANK
      NLOOPCOEFS=0
      DO I=0,RANK
        NLOOPCOEFS=NLOOPCOEFS+(3+I)*(2+I)*(1+I)/6
      ENDDO

      SELECT CASE(MLREDUCTIONLIB(I_LIB))
      CASE(2)
C     PJFry++
      WRITE(*,*)'PJFRY is not installed correctly  !'
      STOP
      CASE(3)
C     IREGI
      WRITE(*,*)'IREGI is not installed correctly  !'
      STOP
      END SELECT

      DO I=1,3
        RES(I)=LOOPCOEFS(0,I_SQSO,I_LOOPGROUP)*TIRCOEFS(0,I)
        DO J=1,NLOOPCOEFS-1
          RES(I)=RES(I)+LOOPCOEFS(J,I_SQSO,I_LOOPGROUP)*TIRCOEFS(J,I)
        ENDDO
      ENDDO
      RES(1)=NORMALIZATION*2.0D0*DBLE(RES(1))
      RES(2)=NORMALIZATION*2.0D0*DBLE(RES(2))
      RES(3)=NORMALIZATION*2.0D0*DBLE(RES(3))
C     WRITE(*,*) 'Loop ID',ID,' =',RES(1),RES(2),RES(3)
      END

      SUBROUTINE ML5_0_INITTIR()
C     
C     INITIALISATION OF TIR
C     
C     LOCAL VARIABLES 
C     
      REAL*8 THRS
      LOGICAL EXT_NUM_FOR_R1
C     
C     GLOBAL VARIABLES 
C     
      INCLUDE 'MadLoopParams.inc'
      LOGICAL CTINIT, TIRINIT
      COMMON/REDUCTIONCODEINIT/CTINIT,TIRINIT

C     ----------
C     BEGIN CODE
C     ----------

C     DEFAULT PARAMETERS FOR TIR
C     -------------------------------  
C     THRS1 IS THE PRECISION LIMIT BELOW WHICH THE MP ROUTINES
C      ACTIVATES
C     USE THE SAME MADLOOP PARAMETER IN CUTTOOLS AND TIR
      THRS=CTSTABTHRES
C     LOOPLIB SET WHAT LIBRARY CT USES
C     1 -> LOOPTOOLS
C     2 -> AVH
C     3 -> QCDLOOP
      LOOPLIB=CTLOOPLIBRARY

C     The initialization below is for CT v1.9.2+
      IF (CTINIT) THEN
        CTINIT=.FALSE.
        CALL ML5_0_INITCT()
      ENDIF
      END

      SUBROUTINE ML5_0_SORT_PJCOEFS(RANK,NLOOPCOEFS,PJCOEFS,TIRCOEFS)
C     
C     CONVERT THE OUTPUT OF PJFRY++ TO THAT OF MADLOOP 
C     
C     THE OUTPUT OF COEFS FROM PJFRY++ IS
C     RANK=0: (,)
C     RANK=1: (0,),(1,),(2,),(3,)
C     RANK=2: (0,0),(0,1),(1,1),(0,2),(1,2),(2,2),(0,3),(1,3),(2,3),(3,
C     3)
C     ...
C     THE OLD OUTPUT OF COEFS FROM MADLOOP IS
C     RANK=0: (,)
C     RANK=1: (0,),(1,),(2,),(3,)
C     RANK=2: (0,0),(0,1),(0,2),(0,3),(1,1),(2,1),(3,1),(2,2),(2,3),(3,
C     3)
C     ...
C     
C     
C     CONSTANTS
C     
      INTEGER LOOPMAXCOEFS
      PARAMETER (LOOPMAXCOEFS=70)
C     ARGUMENTS
      INTEGER RANK,NLOOPCOEFS
      COMPLEX*16 PJCOEFS(0:LOOPMAXCOEFS-1,3)
      COMPLEX*16 TIRCOEFS(0:LOOPMAXCOEFS-1,3)
C     
C     LOCAL VARIABLES
C     
      INTEGER I
      INTEGER POS(0:LOOPMAXCOEFS-1)
      SAVE POS
      LOGICAL INIT
      DATA INIT /.TRUE./
      SAVE INIT
C     ----------
C     BEGIN CODE
C     ----------

      IF(INIT)THEN
        INIT=.FALSE.
C       ASSIGN THE POSITION OF POS FOR SWAP
        CALL ML5_0_ASSIGN_PJPOS(POS)
      ENDIF

      DO I=0,NLOOPCOEFS-1
        TIRCOEFS(POS(I),1:3)=PJCOEFS(I,1:3)
      ENDDO

      END


      SUBROUTINE ML5_0_ASSIGN_PJPOS(POS)
C     
C     ASSIGN THE POSITION OF POS FOR SWAP
C     
C     
C     CONSTANTS
C     
      INTEGER LOOPMAXCOEFS,MAXRANK
      PARAMETER (LOOPMAXCOEFS=70)
      PARAMETER (MAXRANK=4)
C     
C     ARGUMENTS
C     
      INTEGER POS(0:LOOPMAXCOEFS-1)
C     
C     EXTERNAL FUNCTIONS
C     
      INTEGER ML5_0_QPOLYPOS
      EXTERNAL ML5_0_QPOLYPOS
C     
C     LOCAL VARIABLES
C     
      INTEGER I,J,K,SHIFT,DN
      INTEGER POSINDEX(MAXRANK),PJPOSINDEX(MAXRANK)
C     ----------
C     BEGIN CODE
C     ----------
      POS(0)=0
      IF(MAXRANK.LE.0)RETURN
      DO I=1,4
        POS(I)=I
      ENDDO
      IF(MAXRANK.LE.1)RETURN
      SHIFT=4
      DO J=2,MAXRANK
        DN=(J+3)*(J+2)*(J+1)/6
        POSINDEX(1:MAXRANK)=0
        PJPOSINDEX(1:MAXRANK)=0
        DO I=1,DN
          IF(I.GT.1)CALL ML5_0_NEXTINDEX(J,POSINDEX)
          CALL ML5_0_CONVERT_PJPOSINDEX(J,POSINDEX,PJPOSINDEX)
          K=DN-ML5_0_QPOLYPOS(J,PJPOSINDEX)+1+SHIFT
          POS(K)=I+SHIFT
        ENDDO
        SHIFT=SHIFT+DN
      ENDDO

      END

      SUBROUTINE ML5_0_NEXTINDEX(RANK,POSINDEX)
C     
C     CALL FOR THE NEXT INDEX
C     
C     
C     CONSTANTS
C     
      INTEGER MAXRANK
      PARAMETER (MAXRANK=4)
C     
C     ARGUMENTS
C     
      INTEGER RANK
      INTEGER POSINDEX(MAXRANK)
C     
C     LOCAL VARIABLES
C     
      INTEGER I
C     ----------
C     BEGIN CODE
C     ----------
      DO I=1,RANK
        POSINDEX(I)=POSINDEX(I)+1
        IF(POSINDEX(I).GT.3)THEN
          POSINDEX(I)=0
          IF(I.EQ.RANK)THEN
            RETURN
          ENDIF
        ELSE
          IF(I.GT.1)THEN
            POSINDEX(1:I-1)=POSINDEX(I)
          ENDIF
          RETURN
        ENDIF
      ENDDO

      END

      SUBROUTINE ML5_0_CONVERT_PJPOSINDEX(RANK,POSINDEX,PJPOSINDEX)
C     
C     CONVERT POSINDEX TO PJPOSINDEX
C     
C     
C     CONSTANTS
C     
      INTEGER MAXRANK
      PARAMETER (MAXRANK=4)
C     
C     ARGUMENTS
C     
      INTEGER RANK
      INTEGER POSINDEX(MAXRANK),PJPOSINDEX(MAXRANK)
C     
C     LOCAL VARIABLES
C     
      INTEGER I
C     ----------
C     BEGIN CODE
C     ----------
      DO I=1,RANK
        PJPOSINDEX(RANK+1-I)=3-POSINDEX(I)
      ENDDO
      RETURN
      END

      FUNCTION ML5_0_QPOLYPOS(RANK,POSINDEX)
C     
C     COMPUTATION THE RELATIVE POSITION OF INDEX WITH RANK
C     
C     
C     CONSTANTS
C     
      INTEGER MAXRANK
      PARAMETER (MAXRANK=4)
C     
C     ARGUMENTS
C     
      INTEGER RANK
      INTEGER POSINDEX(MAXRANK)
      INTEGER ML5_0_QPOLYPOS
C     
C     EXTERNAL FUNCTIONS
C     
      INTEGER ML5_0_QPOLYNUMBER
      EXTERNAL ML5_0_QPOLYNUMBER
C     
C     LOCAL VARIABLES
C     
      INTEGER I,J,IMIN
C     ----------
C     BEGIN CODE
C     ----------

      IF(RANK.EQ.0)THEN
        ML5_0_QPOLYPOS=1
        RETURN
      ENDIF

      IF(RANK.EQ.1)THEN
        ML5_0_QPOLYPOS=POSINDEX(1)+1
        RETURN
      ENDIF

      ML5_0_QPOLYPOS=POSINDEX(1)-POSINDEX(2)+1
      DO I=2,RANK
        IF(I.EQ.RANK)THEN
          IMIN=0
        ELSE
          IMIN=POSINDEX(I+1)
        ENDIF
        DO J=IMIN,POSINDEX(I)-1
          ML5_0_QPOLYPOS=ML5_0_QPOLYPOS+ML5_0_QPOLYNUMBER(J,I-1)
        ENDDO
      ENDDO
      RETURN
      END

      FUNCTION ML5_0_QPOLYNUMBER(I,RANK)
C     
C     THE INDEPENDENT NUMBER OF Q POLY WITH \MU=I,...,3 AND RANK
C     
C     
C     CONSTANTS
C     
C     
C     ARGUMENTS
C     
      INTEGER I,RANK
      INTEGER ML5_0_QPOLYNUMBER
C     
C     LOCAL VARIABLES
C     
C     ----------
C     BEGIN CODE
C     ----------
      SELECT CASE(I)
      CASE(0)
      ML5_0_QPOLYNUMBER=(3+RANK)*(2+RANK)*(1+RANK)/6
      CASE(1)
      ML5_0_QPOLYNUMBER=(2+RANK)*(1+RANK)/2
      CASE(2)
      ML5_0_QPOLYNUMBER=(1+RANK)
      CASE(3)
      ML5_0_QPOLYNUMBER=1
      CASE DEFAULT
      STOP 'I must be >= 0 and <=3 in ML5_0_QPOLYNUMBER.'
      END SELECT
      RETURN
      END

      SUBROUTINE ML5_0_CHOOSE_LOOPLIB(LIBINDEX,NLOOPLINE,RANK
     $ ,COMPLEX_MASS,DOING_QP,I_LIB)
C     
C     CHOOSE THE CORRECT LOOP LIB
C     Example:
C     MLReductionLib=3|2|1 and LIBINDEX=3
C     IF THE LOOP IS BEYOND THE SCOPE OF LOOP LIB MLReductionLib(3)=1
C     USE LIBINDEX=1, and LIBINDEX=2 ...
C     IF IT IS STILL NOT GOOD,STOP
C     
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER NLOOPLIB,QP_NLOOPLIB
      PARAMETER (NLOOPLIB=3,QP_NLOOPLIB=1)
C     
C     ARGUMENTS
C     
      INTEGER LIBINDEX,NLOOPLINE,RANK,I_LIB
      LOGICAL COMPLEX_MASS,DOING_QP
C     
C     LOCAL VARIABLES
C     
      INTEGER I,J_LIB,LIBNUM
      LOGICAL LPASS
C     
C     GLOBAL VARIABLES
C     
      INCLUDE 'MadLoopParams.inc'
C     TILL NOW, ONLY CUTTOOLS PROVIDE QP
      LOGICAL QP_TOOLS_AVAILABLE
      INTEGER INDEX_QP_TOOLS(QP_NLOOPLIB)
      COMMON/ML5_0_LOOP_TOOLS/QP_TOOLS_AVAILABLE,INDEX_QP_TOOLS
C     ----------
C     BEGIN CODE
C     ----------

      IF(DOING_QP)THEN
C       QP EVALUATION, ONLY CUTTOOLS
        IF(.NOT.QP_TOOLS_AVAILABLE)THEN
          STOP 'No qp tools available, please make sure MLReductionLi'
     $     //'b is correct'
        ENDIF
        J_LIB=0
        DO I=1,QP_NLOOPLIB
          IF(INDEX_QP_TOOLS(I).EQ.LIBINDEX)THEN
            J_LIB=I
            EXIT
          ENDIF
        ENDDO
        IF(J_LIB.EQ.0)THEN
          STOP 'CANNOT find the correct qp tool'
        ENDIF
        I=J_LIB
        I_LIB=LIBINDEX
        LIBNUM=MLREDUCTIONLIB(I_LIB)
        DO
        CALL DETECT_LOOPLIB(LIBNUM,NLOOPLINE,RANK,COMPLEX_MASS,LPASS)
        IF(LPASS)EXIT
        I=I+1
        IF(I.GT.QP_NLOOPLIB.AND.INDEX_QP_TOOLS(I).EQ.0)THEN
          I=1
        ENDIF
        IF(I.EQ.J_LIB)THEN
          STOP 'No qp loop library can deal with this integral'
        ENDIF
        I_LIB=INDEX_QP_TOOLS(I)
        LIBNUM=MLREDUCTIONLIB(I_LIB)
        ENDDO
      ELSE
C       DP EVALUATION
        I_LIB=LIBINDEX
        LIBNUM=MLREDUCTIONLIB(I_LIB)
        DO
        CALL DETECT_LOOPLIB(LIBNUM,NLOOPLINE,RANK,COMPLEX_MASS,LPASS)
        IF(LPASS)EXIT
        I_LIB=I_LIB+1
        IF(I_LIB.GT.NLOOPLIB.OR.MLREDUCTIONLIB(I_LIB).EQ.0)THEN
          I_LIB=1
        ENDIF
        IF(I_LIB.EQ.LIBINDEX)THEN
          STOP 'No dp loop library can deal with this integral'
        ENDIF
        LIBNUM=MLREDUCTIONLIB(I_LIB)
        ENDDO
      ENDIF
      RETURN
      END

